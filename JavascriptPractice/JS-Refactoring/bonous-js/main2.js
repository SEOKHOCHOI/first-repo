// 프로그래밍 언어에서 우리가 필요한 데이터를 담는것이 변수이다.
// 그럼 함수는 무엇인가?

/*
    const num = 1;
    const num2 = 2;
    const result = num + num2;
    console.log(result);
    우리가 이렇게 변수에 데이터를 담아놓고 
    더하는 작업을 하게되면 결과값에 더한아이를넣고
    출력해 본다면 3 이 출력된다.

    이렇게 반복적으로 쓰이는 일들을 계속해서 하게된다면
    const num3 = 1;
    const num4 = 2;
    const result2 = num3 + num4;
    console.log(result);
    이렇게 저것과 똑같은 코드를 여러번 만들어야한다.
    이렇게 계속 하는것은 성가신 일이다.

    그래서 프로그래밍을 짤때 무언가 반복적으로 되는
    위같은 로직들이 있다면 이것을 함수로 만들게된다!

    왜냐? 함수로 만들면 재사용이 가능하기 때문에!!

    함수는 function 이라는 키워드를써서 함수의 이름을
    지정이 가능하고, 위같은 로직은 함수의이름()에서 ()에 
    (a, b)이렇게 a와 b를 받아서 
    return a + b; 해주면된다.

    즉, function add(a, b) {
        return a + b;
    }이다.

    add라는 함수는 
    우리가 정의한 코드블럭인 {}안의 기능,
    즉, 우리가 작성한 코드블럭의 아이가 포함이야.
    여기까지가 함수야.
    {}안의 것들을 코드블럭이라 하는데 여기에
    add라는 이름을 지정해 준거야!
    그리고 JS엔진에게 이건 이 add는 이제 함수야~ 
    라고 말해주는게 function 이라는 키워드야!
    
    이름은 add 처럼 가능하면 의미있는 이름을 사용해!
    add를 길게 작성하지 않아도 되는것은 사실
    함수를 선언할때 ()안에 들어있는 아이들이
    몇가지의 인자를 받는지를 정의하는거야.
    이 함수는 a와 b라는 두가지의 어떤 값을 받아오는데
    타입스크립트나 자바나 이런 타입이 있는 언어는
    사실 a: number, b:number 이렇게 임의의 a와b인데
    숫자인 a와 b를 받아온다 라고 조금더 직관적 이해가 가능한데,
    근데 JS에는 타입이 없다. 그래서 우리가 그냥 유추하는거야.
    여기서 우리가 헷갈려 하는게 a와 b는 우리가 변수에서
    정의하는 이름처럼 우리가 만든 이름이야!
    그래서 이것을 num1, num2 이런식으로 작성해도돼.
    (num1, num2) 이 인자는 우리가 외부에서 어떤값을
    받아올건데 그 받아오는 값을 num1, num2 이런아이들을
    통해서 {} 여기 블럭안에서도 접근이 가능한것이다.

    그래서 add라는 함수는 2가지의 데이터를 받아오는데
    어떤 데이터가 들어갈지는 이 add라는 함수를
    호출하는 사람이 결정하겠지?
    그래서 함수 자체에서는 이걸 작성하는 시점에는 num1, num2에 어떤
    데이터가 들어갈지는 알수가 없지만 우리가 num1 이런
    이름을 통해서 num1과 num2를 더한값을 리턴하겠다.
    return num1 + num2; 가 되는거야.

    이제 저 function add(num1, num2) {
        return num1 + num2;
    } 을 호출해보면  //여기까지는 add라는 함수를 그냥 정의한것
    
    const sum = add(3, 4); //sum이라는 변수선언하며 add함수 호출.
    함수는 이제 실제 데이터를 3과 4라 지정해줌.

    이렇게 함수를 호출하면 실제로 데이터가 전달이돼.
    즉 이 함수를  호출하는것은 add라고 정의된 함수에
    드디어 num1에는 3이 num2에는 4가 이렇게 지정이되고
    함수가 호출되면서 우리가 정의한 코드블럭{}가 실행이되며
    결국엔 return해주는거야. 더해져서 7이 리턴되겠지?
    그래서 7이 sum이라는 변수에 할당이돼.
    그래서 console.log(sum); 하면 7이 출력이돼.
*/

/*
    함수도 함수를 정의할때
    함수에서 쓰인.. {}여기 정의한 코드블럭이
    메모리 어딘가에 만들어진다.
    그래서 num1, num2라는 어떤 두가지의 인자를 받는 함수가
    어떤값을 더해서 retrun하는 것까지 정의한 이 자체가
    메모리 어딘가에 들어있고
    이 add라는 함수의 이름은 사실 변수처럼 코드가 작성되어있는..
    함수도 오브젝트중 하나라고 했지?
    이 함수가 들어있는 ref..레퍼런스 즉 함수{} 애들이 들어있는
    이걸 가리키고 있는 주소같은 아이가 들어있다.
    이건 오브젝트라 똑같지? 그래서 add라는 함수이름은
    함수가 정의된곳을 가리키고있는 레퍼런스가 들어있다.

    그래서 우리가 두썸띵이라는 변수에 add를 할당하게되면?
    const doSomething = add; 이러면
    똑같이 doSomething이라는 이름의 변수가 공간이
    할당이 되는데 이 공간에는 add가 가리키고있는 ref가
    복사되어 들어와! 그래서 두썸딩이나 add가
    똑같은 함수를 가리키고있다!! 오브젝트랑 똑같지?!

    그래서 함수는 add 이름 자체는 함수가 정의된곳을 가리키고
    이 함수를 실행하기 위해서는 괄호도 해주고 필요한데이터를
    전달해 줘야겠지? 그래서 우리가
    결과값을 두썸띵이라는 변수에 함수가 들어있으니..
    함수를 실행하기 위해서 괄호를 이용해 2,3을 더한값을
    한다음에 출력을 해보면..? console.log(result);
    5가 나오는걸 알수있어!

    그래서 결국
    const result = doSomething(2, 3);과
    const result2 = add(2, 3);은 
    똑같아! 똑같은!!!! 함수를 2번 실행하게 되는거야!

    여기까지 완벽히 이해해야 콜백함수에서 무너지지않는다!!

    이제 함수 인자에대해 좀 더 생각해보자.
    add라는 함수는 num1, num2라는 두가지의 인자를
    받는 함수잖아?

    그런데 만약 다른함수를만들게되면..
    function print() {
        console.log('print');
    }
    얘는 별도로 인자를 받는 함수는 아니고 아무런
    input도 받지 않고 그냥 자체적으로 무언가를 
    print 하는 아이다.

    그래서 만약 우리가 print를 호출할때 저거 밑에
    print(); 하게 되면 print가 출력이 된다.
    print(2, 3); 여기에 이렇게 몇가지의 데이터를
    전달하던 아무것도 일어나지 않는다.
    즉, 우리가 아무리 많은 input을 전달해도
    이 print는 그 인풋을 무시해! 쓰질 않아!
    그래서 이렇게 아무런 인자를 받지 않는 함수는
    input을 받지 않는다! 만약 여기서 우리가 받아온
    (2, 3)d요 데이터를 접근하고 싶다면 add와 똑같이
    이름을 지정해주면 된다.
    function print(a, b) {
        console.log(`${a} ${b}`);
    }
    pinrt(2, 3);

    이렇게 해주면 이제 함수 내부에서 접근이 가능하여
    2 3 이렇게 출력된다!
    그래서 인자는 함수를 호출하는 사람으로부터 필요한 데이터를 
    받아오기 위해서 그리고 필요한 데이터를 받아올 때
    우리가 함수 내부에서 조금더 이해하기 쉬운
    의미있는 이름을 a, b 이 자리에 부여해 놓는거야.
    그래서 아까 num1, num2 이렇게 쓴거고.
*/

/*
    function surprise(operator) {
        const result = operator(2, 3);
        console.log(result);
    }

    surprise(add);
    이 함수는 동작을 수행하는 어떤 oprator라는
    인자를 받는데 이 함수는 재밌는걸 한다.
    뭘 하냐면 받아온 operator라는 인자를 실행한다.
    실행해서 그 결과값을 내부 result라는 값에
    할당해서 이것을 출력한다.
    이거를 surprise(); 이렇게 그냥 호출하게 되면
    오퍼레이터라를 인자를 받아와서 해야하는데 
    오류가 발생한다. 왜냐? 오퍼레이터는 함수가 아니야
    라고 에러가 나왔다.
    왜냐? 지금 오퍼레이터는 아무런 값을 전달하지 않았기
    때문에 언디파인으로 되어있기 때문이다.

    그래서 surprise(add); 이렇게 surprise에 add라는 함수를 전달하면 
    add라는 함수가 있는데 아까랑 똑같이 코드블럭이 
    들어있겠지? num1, num2 두가지의 숫자를 받아서
    숫자 하나를 retrun하는 함수다.이 함수를 add라는 
    변수가.. 즉 함수이름이 가리키고 있지?
    그리고 surprise라는 함수에 add 자체를 전달한다.
    즉, add가 가리키고 있는 함수의 주소값 
    즉 add라는것은 add자체의 변수 공간에 할당되어서
    add가 가리키고 있는 ref가 들어있지?
    그래서 surprise의 (operator)여기 인자에는
    add의 ref가 복사되어서 전달이된다.
    그래서 result는 operator를 호출한다는 것은 당연히
    이 ref가 결국 add함수를 가리키고있지? 
    그래서 add를 수행하는것과 동일하다.
    근데 이렇게만 하게되면 낫어넘벌 NaN이 나온다. 왜냐?
    지금 num1, num2에 아무런 데이터도 전달해주지 않았거든
    그래서 const result = operator();를 operator(2, 3);
    으로해서 2와 3을 전달하게 되면 5가 출력이돼!
    이건 add를 호출한것과 똑같아!

    function divide(num1, num2) {
        return num1 / num2;
    }

    function surprise(operator) {
        const result = operator(2, 3); // add(2, 3)과 동일
        console.log(result);
    }

    surprise(divide); 

    이렇게 divide라는 함수의 ref를 전달하게 되면 
    이제 더하는게 아니라 divide를 호출하는것과 똑같지?
    그래서 2를 3으로 나눈값이 출력이 된다.

    이런식으로 함수를 전달한다는것은 함수를 가리키고있는
    ref가 복사 되어서 전달되는거란걸 기억하자.
    그래서 전달된 이 ref를 일반함수를 호출하는 것처럼
    괄호를 이용해서 operator(2, 3) 이렇게.. 호출할수가
    있다. 그리고 function surpirse(여기여기!!) 의 인자의
    이름은 우리가 정하는 것과 똑같다. 대신 저 부분을
    함수 내부에서 쓰이는 로직에서도 동일하게 이름을 써서
    접근해야 한다.


    
    참고로 타입스크립트라면 
    operator: number   아~서프라이즈는 오퍼레이터라는 숫자를 받아오구나 라고 직관적으로 이해가 된다.
    operator: () => {} 아 오퍼레이터는 콜백함수를 받는구나~
    operator: function 아~ 함수를 받아오구나
    이런식으로 이해하면 되는데 JS는 그런게 없다.
*/