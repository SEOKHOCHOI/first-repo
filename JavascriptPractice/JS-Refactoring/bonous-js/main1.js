// 우리가 조금더 코드를 어떻게 구조적으로 재사용 가능하게 
// 이쁘게 만들 수 있을지에 대해서 얘기해보자!

/*
    practice1~ practice13까지 
    JS의 전반적인 내용과 브라우저에서 쓰이는 JS들
    그리고 브라우저에 대한 개념을 모두 정리했다고 봐도돼.

    이제부터 할 내용들은 브라우저에 관련된 내용이라기보다는
    우리가 조금 더 코드다운 코드를 작성할수있도록 
    실력을 향상하는 시간이다!

    그래서 JS에 대한 기볹거인 개념이 없으면 
    지금부터 작성할 리팩토링을 진행하는데 조금 힘들수있다.
*/

//변수부터 순서대로 살펴보자!
/*
    변수: 
    프로그래밍 언어에서 우리가 처리해야 되는 데이터를
    담을 수 있도록 도와주는 아이.
    즉, 데이터를 담고있는 아이.

    그래서 변수를 통해서 우리가 데이터에 접근하고
    데이터를 업데이트 할 수 있다.

    let:
    JS에서 변수를 만들때는 let 키워드 이용해야함.
    그 후 let number 이렇게 number라는 변수의 이름을
    정의할수가 있어. 그 후 let number = 2; 이렇게
    숫자 2를 할당하게 되면 숫자2가 number라는 변수에
    할당이 되는거다. 변수의 이름은 원하는대로 정의가능.
    위처럼 숫자도되고 let num = '2'; 이렇게 문자열도가능.
    이렇게 담을수있는 가장 작은 단위의 데이터들을 
    primitive 데이터 타입이라고 하는데 이런 이름을 떠나서
    데이터 타입은 number나 string, boolean, null,
    undefined, symbol 이런 아이들이 가장 작은 단위의 애들이다.
    여기서 symbol은 많이 쓰이는 애가 아니니 일단 무시하자.

    근데 실제로 할때는 그냥 number라고 하는것보다 
    우리가 프로그래밍 할때 로직과 연관된 의미있는 이름을
    지정하는게 좋다. 예를들어 그냥숫자라고 하는거보다
    나이인 age라고 정의해주면 이 변수에는 무언가 나이
    정보를 담고 있구나라고 어떤 정보를 가지고 있는지
    조금 더 유추하기가 쉬운것이다.

    한 가지 포인트는 저런 작은 단위의 아이들은 우리가 변수를
    let number = 2; 이렇게 선언하는 동시에 
    메모리에 우리의 변수를 위한 메모리공간이 생긴다.
    이 메모리공간에는 우리가 정의한 number를 위한
    변수의 공간이 생기고, 그리고 저렇게 2를 할당한다는 것은
    여기 공간에 2라는 데이터가 적재되어진다.
    즉, number라는 변수안에 2라는 숫자의 데이터가 
    들어있게 되는것이다.

    여기서 만약 let number2 = number; 이렇게
    number2라는 변수에 number을 할당하게 되면
    다시 number2라는 변수를 선언했기 때문에 또 다른 공간에
    number2만을 위한 공간이 생긴다. 다시말해.
    변수를 선언하면 무조건 그 변수를 위한 공간이 생긴다.
    이것을 조금 더 세부적으로 얘기하면 메모리에 어느정도 바이트
    사이즈의 데이터 공간이 확보된다. 이렇게 말할수 있는데
    위처럼 number2에 number라고 할당하게 되면 
    number라는 변수에 들어있는 2라는 데이터를 그대로 복사해서
    number2의 공간에 할당하게 되는것이다.

    그래서 console.log(number); console.lob(number2);
    이렇게 콘솔에 출력해보면 당연히 2와 2가 출력이 된다.

    여기서 이어서 number2 = 3; 이렇게 업데이트했다면?
    number2에는 숫자 3이 들어있게돼.
    그래서 다시 console.log(number2); 해보면 3이출력돼.
    number의 값을 복사해서 number2에 넣은거기 때문에 
    number2의 값을 변경한다고 number에 영향을 주진 않아.

    이제 여기서.. 데이터 타입은
    // number, string, boolean, null, undefined...이런
    애들을 제외한 모든 아이들은 다 object라고해.

    object란:
    최소한 한 두가지의 다양한 데이터를 
    한군데다 묶어놓은 아이다. 라고 할 수 있어.
    배열,리스트 이런 데이터 타입이나 함수도 다 object야.

    object는 적어도 한두가지 이상의 큰 데이터가 들어있기 때문에
    우리가 단순히 변수를 선언하는 곳에 다 담아놓을수가없어.
    그래서 얘네는 얘네만의 공간에 있어.
*/

/*
    object는 위와는 조금 달라!
    똑같이 let이라는 변수에 우리가 임의로 만든 obj라는
    변수에 오브젝트를 만들어보자.
    오브젝트에는 key와 value로 구성이 되어져 있는데
    name이라는 key에는 ellie라는 value이 들어있고
    age라는 key에는 숫자 5가 들어있다.
    let obj = {
        name: 'ellie',
        age: 5,
    };  이렇게 말이다. 이렇게 됐을때는 메모리에 무슨일이 발생하느냐?
    메모리에는 name에 해당하는.. name도 즉, 결국은
    object에 있는 key도 각각 key마다 메모리가 할당된다고 생각하면 돼.
    name이라는 메모리공간에 ellie라는 value가 들어가있고
    age라는 변수에 숫자 5가 들어있는거야.
    그리고 얘네들을 묶어서.. 얘네들을 나타낼수있는..
    우리가 집집마다 주소가있고 사람마다 주민등록 번호가 있듯이
    얘네들이 들어있는 위치를 나타내는 레퍼런스가 있다.

    예를 들어서 메모리가 만약 1번 2번 3번.. 1 2 3 이라는 주소에
    위의 애들 정보가 들어있다고 생각해보자.
    그러면 이제 object라는 변수에는 즉, obj라는 변수에는
    1 2 3 이 들어와있다.
    오브젝트는 너무 크기 때문에 변수 한 공간안에 들어가기에 너무 크다.
    그래서 오브젝트도 각각 키 마다 name은 ellie 이렇게
    공간이의 할당이 따로 되어져있고 이것들을 묶어서
    가리키고 있는 주소가 있는데 그 주소 1 2 3 만 obj라는 변수에
    할당이 되는것이다.

    여기서 변수를 이용해서 obj.name 이라고 하게되면 
    obj가 아 얘는 지금 무언가를 가리키고 있구나
    123이 가리키는 곳에 name이라는 변수의 값을.. ellie를
    찾고 있구나 라고 이해할수가 있는거야.

    그래서 우리가 console.log(obj.name);
    이렇게 출력하면 ellie 라고 출력이 되는것이다.

    이제 우리가 아까 number2에 number를 할당했듯이
    똑같은걸 해보자.
    obj2라는 변수를 만들면서 obj를 할당해보자.
    let obj = {
        name: 'ellie',
        age: 5,
    };
    console.log(obj.name);

    let obj2 = obj;     이러게 말이다.

    그럼 무슨일이 발생하느냐? 똑같이 변수를 선언했으니까
    obj2라는 변수의 새로운 메모리공간이 생기고,
    이제 obj를 할당할껀데.. obj는 무언가를 가리키는
    주소 123이 들어가있네? 
    변수를 할당할때는 무조건 그 변수에 들어가있는 값이 
    복 사 되 어 서 들어온다.
    즉, obj가 가지고 있는 이 123이라는 주소가 복사되어서
    그대로 obj2에 123 이라고 가지고 와지는것이다. 

    그래서 console.log(obj2.name); 이렇게 obj2에
    이름을 이렇게 접근해서 출력하게되면 결국은
    obj안에 들어있는 123에 주소를 이용해서 얘가
    가리키고 있는 name의 값인 ellie를 출력하면 되는구나
    라고 이해할수있다.
    
    여기까지는 앞에서 봤던 순수 primitive타입과 동일하지?

    하지만! 
    이제 프리미티브 타입도 오브젝트도
    변수를 할당할때 변수안에 들어있는 값이 복사되어서 들어온다.
    하지만 그냥 숫자나 스트링이나 불리언은 그 데이터 자체가
    변수에 담겨있어서 데이터 자체가 복사되어서 들어오지만
    오브젝트는 이 오브젝트를 가리키고 있는 주소만 들어오기에
    그 오브젝트를 가리키고 있는 주소만 복사 되어서 들어온다.
    여기까지를 이해해야돼.
    그래서 이제! 이런 재밌는 일을 할 수 있어.

    obj의 name을 james라고 만들면 어떤일이 발생할까?
    obj.name = 'james'; 하면
    obj는 123을 가리키고 있네?
    가리키고 있는곳의 .name 즉 이름을 james로 바꿨다.
    그러면 이제 동일하게 
    console.log(obj.name);
    console.log(obj2.name);   두가지를 출력해보면
    둘다 james 라고 업데이트 되었다.
    obj나 obj2나 결국은 가리키고 있는 오브젝트가
    동일하기 때문에 이렇게 어떤 곳을 통해서 이름을
    업데이트 해도 둘다 변경된 것이 보인다.
    아까 변수와는 조금 다르지?

    다시 정리해보자.
    변수를 let obj2이런식으로 선언하면 우리가 데이터를 담을수있는
    공간이 할당이 되고 obj2라고 이름을 만든아이가
    할당된 공간을 가리키고 있다.
    숫자,스트링,불리언,널,언디파인같은경우는 데이터가 
    작은 단위기 때문에 메모리에 그대로 들어오지만
    오브젝트처럼 뚱뚱한 아이는 이렇게 들어올수 없기 때문에
    오브젝트 아이들은 그 오브젝트가 따로 어딘가에 할당이
    되어있고 이 아이를 가리키고 있는 주소같은 아이가 있는데
    그것을 ref..레퍼런스라고 한다.
    그리고 변수를 다른 변수에 할당하거나 전달할때
    변수안에 들어있는 값이 복사되어서 가는데 이런 그냥 
    데이터 타입은 값 자체가 들어있으니까 값 자체가
    복사되어 전달이 되지만 오브젝트 같은 경우는
    레퍼런스가 복사 되어서 전달된다.

    그래서 오브젝트를 통해서 무언가 데이터를 변경하면 우리가
    이 오브젝트가 가리키고 있는 데이터가 업데이트 되는것이다.

    여기서 조금 헷갈려했던 부분은
    let a = 2;
    a = 5;
    let은 선언하고 난 뒤에도 값을 a =5; 처럼 또 바꿀수있다.
    const라는 이 상수 변수는
    한번 선언하고나면 const a = 2;
    절대로 변경이 불가능해. a = 5; 이래버리면 에러뜨는거야.
    const로 정의를 한번 하게되면 절대로 그 값변경불가야!
    그런데 여기서 헷갈려 했던게..
    그럼 왜 object는 const obj = {} 이렇게 const로
    했는데 왜 우리가 여기서 이름이 변경이 왜 되는거야???
    라는 의문이 있었는데 이게 무엇이냐면..
    obj라는 변수를 상수변수 const로 만들면
    이제 이 obj가 담겨있는.. 결국은 얘네 오브젝트를 어딘가를
    가리키고 잇는 ref..레퍼런스가 들어있겠지?
    이 obj라는 변수에는 이제 다른값이 할당이 안돼.
    그래서 우리가 만약에 
    const obj = {
        name: 'ellie',
        age: 5,
    };  후에

    obj = {   obj에 이제 다른 오브젝트를 한번 할당해볼까?
        name: 'james',
        age: 7;
    } 이게 안된다는 얘기야.
    이제 이런식으로 자체의 레퍼런스가가 변경이 불가능해.
    이 오브젝트가 할당이 된 레퍼런스 값은 잠겨있어!!!!
    여기 공간이 잠겨있어!!! 대신 이 레퍼런스..ref자체를
    다른 레퍼런스로 변경은 불가능하지만

    obj.name = 'james';
    이렇게 obj가 가리키고있는 이름을 다른거로 바꾸는건 가능해.
    왜냐면 우리가 이 obj의 ref공간은 이제 잠겨서 더이상
    변경이 불가능 하지만 이 ref가 가리키고 있는것을 이용해서
    ref에게 가리켜지고 있는 얘들은 변경이 하기하기 때문이야.
    상수 변수를 쓴다는 것은 이 상수 변수가 담겨있는것
    자체가 변경이 불가능한거야.
    그래서 그냥 우리가 넘버..숫자는 이 값 자체가 담겨있어서
    값이 변경이 불가능하지만 오브젝트는 오브젝트 자체가
    담겨있는게 아니라 오브젝트는 어딘가에 따로 저장돼있고
    얘네를 가리키고 있는 ref가 들어있기 때문에
    이 ref는 다른 오브젝트로 변경이 불가능 하지만
    이 ref가 가리키고 있는 오브젝트의 안의 내용은
    변경이 가능해!!
*/
